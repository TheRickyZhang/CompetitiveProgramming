A: 1200
Can greedily keep track of largest imbalance.

B: 1600
Not confident on approach: Can hash each node state as a 3-tuple. For each v, count u-v paths by map count of hash. Update dynamically over DFS

C: 2800?
No idea where to even start with an efficient solution. Maybe you can binary search on how many you can cover?

D: Ordered Problem Set - 1200
Create max sparse table and try every value of k

E: Eccentric Excursion - 3000
Let x = number of total "forks" when leaf is at node. For instance: 0->[1, 2, 3] has 2 forks.
Then the minimum number of k-edges needed when u is root is x+1 - deg(u). Call this our flight balance.
Pick the lowest node with balance <= k as root.
Go through next unvisited nodes in order value. If, after removing the u->anc(v) edge and adding the u->v edge, the node balance <= k, go to v. Keep doing this.

The only issue is that you might end up using less than k flights.
